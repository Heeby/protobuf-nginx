#include "config.h"
#include <google/protobuf/io/zero_copy_stream.h>
#include <ngx_generator.h>

namespace google {
namespace protobuf {
namespace compiler {
namespace nginx {

bool
Generator::Generate(const FileDescriptor* file,
		    const std::string& parameter,
		    OutputDirectory* outdir,
		    std::string* error) const
{
  std::string root(FileRoot(file->name()));
  std::string dotc(root + ".c");
  std::string doth(root + ".h");
  std::string conf("config");

  scoped_ptr<io::ZeroCopyOutputStream> source(outdir->Open(root + "/" + dotc));
  scoped_ptr<io::ZeroCopyOutputStream> header(outdir->Open(root + "/" + doth));
  scoped_ptr<io::ZeroCopyOutputStream> config(outdir->Open(root + "/" + conf));

  io::Printer sprint(source.get(), '$');
  io::Printer hprint(header.get(), '$');
  io::Printer cprint(config.get(), '*');

  std::map<std::string, std::string> vars;

  vars["p"] = PACKAGE;
  vars["v"] = VERSION;
  vars["g"] = IncludeGuard(doth);
  vars["h"] = doth;
  vars["r"] = root;

  // the module config file

  cprint.Print("ngx_addon_name=*root*_module\n"
               "\n"
               "HTTP_MODULES=\"$HTTP_MODULES *root*_module\"\n"
               "NGX_ADDON_DEPS=\"$NGX_ADDON_DEPS $ngx_addon_dir/*root*.h\"\n"
               "NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_addon_dir/*root*.c\"\n",
               "root", root);

  // the header file

  hprint.Print(vars,
               "/* Generated by $p$ $v$ - DO NOT EDIT */\n"
               "\n"
               "#ifndef $g$\n"
               "#define $g$\n"
               "\n"
               "#include <stdint.h>\n"
               "#include <ngx_config.h>\n"
               "#include <ngx_string.h>\n"
               "#include <ngx_array.h>\n"
               "#include <ngx_palloc.h>\n"
               "#include <ngx_rbtree.h>\n"
               "#include <ngx_protobuf.h>\n");

  for (int i = 0; i < file->dependency_count(); ++i) {
    hprint.Print("#include <$droot$/$droot$.h>\n",
                 "droot", FileRoot(file->dependency(i)->name()));
  }

  hprint.Print("\n");

  for (int i = 0; i < file->enum_type_count(); ++i) {
    GenerateEnumDecl(file->enum_type(i), hprint);
  }

  for (int i = 0; i < file->message_type_count(); ++i) {
    GenerateTypedef(file->message_type(i), hprint);
  }

  for (int i = 0; i < file->message_type_count(); ++i) {
    GenerateMethodDecls(file->message_type(i), hprint);
  }

  if (file->extension_count() > 0) {
    hprint.Print("/* file-level extensions */\n");

    for (int i = 0; i < file->extension_count(); ++i) {
      GenerateExtensionFieldDecls(file->extension(i), hprint);
    }
    hprint.Print("void $root$__export_extensions(void);\n"
                 "\n",
                 "root", root);
  }

  hprint.Print(vars,
               "#endif /* $g$ */\n");

  // the module source file

  sprint.Print(vars,
               "/* Generated by $p$ $v$ - DO NOT EDIT */\n"
               "\n"
               "#include <ngx_protobuf.h>\n"
               "#include <$r$/$h$>\n"
               "\n");

  for (int i = 0; i < file->message_type_count(); ++i) {
    GenerateDescriptors(file->message_type(i), sprint);
  }

  if (file->extension_count() > 0) {
    sprint.Print("/* extension field descriptors */\n"
                 "\n");

    for (int i = 0; i < file->extension_count(); ++i) {
      GenerateFieldDescriptor(file->extension(i), sprint);
    }
  }

  GenerateModule(file, sprint);

  for (int i = 0; i < file->message_type_count(); ++i) {
    GenerateMethods(file->message_type(i), sprint);
  }

  if (file->extension_count() > 0) {
    sprint.Print("/* file-level extensions */\n"
                 "\n");

    for (int i = 0; i < file->extension_count(); ++i) {
      GenerateExtensionFieldMethods(file->extension(i), sprint);
    }
  }

  return true;
}

} // namespace nginx
} // namespace compiler
} // namespace protobuf
} // namespace google
